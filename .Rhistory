geom_jitter(width = 0.12, alpha = 0.6) +
scale_fill_brewer(palette = "Greens") +
theme_classic()+
theme(legend.position = "none") +
geom_hline(yintercept = 60, lty = "dashed")+
labs(x = "Q rating", y = "Altitude (m)")
ggsave("Figures/Altitude_vs_Quality.png",
p1, width = 5, height = 5)
range(morpho.output$altitude.c)
p1<- ggplot(morpho.output, aes(x = as.factor(Q), y = altitude.c, fill = as.factor(Q))) +
geom_boxplot() +
geom_jitter(width = 0.12, alpha = 0.6) +
scale_fill_brewer(palette = "Greens") +
theme_classic()+
theme(legend.position = "none") +
geom_hline(yintercept = 70, lty = "dashed")+
labs(x = "Q rating", y = "Altitude (m)")
p1
getwd()
ggsave("Figures/Altitude_vs_Quality.png",
p1, width = 5, height = 5)
id.morph
summary(id.morph$Q)
summary(as.factor(id.morph$Q))
# Summarize by individual ID
dat_id <- dat %>%
group_by(ID) %>%
summarise(
mean.TL = mean(TL.m, na.rm = TRUE),
sd.TL = sd(TL.m, na.rm = TRUE),
mean.Ratio.HF = mean(ratio.HF, na.rm = TRUE),
sd.Ratio.HF = sd(ratio.HF, na.rm = TRUE),
mean.Ratio.HD = mean(ratio.HD, na.rm = TRUE),
sd.Ratio.HD = sd(ratio.HD, na.rm = TRUE),
is_male = any(notes == "male", na.rm = TRUE)  # Flag known males
)
ggplot(morpho.output, aes(x = altitude.raw, y = as.factor(Q), fill = as.factor(Q), alpha = 0.9))+
geom_density_ridges2()+
scale_fill_brewer(palette = "Greens")+
theme(legend.position = "none")
View(id.mean)
View(id.mean)
View(id.mean)
id.mean%>%
filter(n_photos>1)
id.mean%>%
filter(n_photos>1 & !is.na(mean_HD))
hd<-id.mean%>%
filter(n_photos>1 & !is.na(mean_HD))
View(hd)
hf<-id.mean%>%
filter(n_photos>1 & !is.na(mean_HD))
hf<-id.mean%>%
filter(n_photos>1 & !is.na(mean_HF))
hf$n_photos
hd$n_photos
# Load required packages
source("Scripts/functions.R")
library(tidyverse)
# 1. Read and clean data -----
#raw reads from Morphometrix
morpho.output <-read.csv("Data/morpho.output.batch2.csv", header = T)
# get .mp4 file name
morpho.output<-morpho.output%>% mutate(
video.file = substr(imageName, 1, 32)
)
# get within-video whale ID and date
morpho.output <- morpho.output %>% mutate(
video.whale.ID =paste(video.file, ind, sep = "_"),
date = substr(video.whale.ID, 18,25)
)
# get correct altitude data from drone srt files
morpho.output <- getSrtAltitude(morpho.output)
# get and ration length estimates
morpho.output<- morpho.output %>% mutate(
altitude.c = altitudeASL(altitude.raw = droneAltitude), #add launch height to barometer altitude:
TL.m = measureWhales(image.width = image_width, altitude = altitudeASL(altitude.raw = droneAltitude),length.pixels = TL.px), #estimate length in meters
HD.m = measureWhales(image.width = image_width, altitude = altitudeASL(altitude.raw = droneAltitude),length.pixels = HD.px), #estimate length in meters
HF.m = measureWhales(image.width = image_width, altitude = altitudeASL(altitude.raw = droneAltitude),length.pixels = HF.px),
ratio.HD = HD.px/TL.px, # ratio using nose-dorsal fin measure
ratio.HF = HF.px/TL.px, # ratio using nose- flipper measure
ratio.DF = HF.px/HD.px # ratio nose-flipper to nose DF
)
# 1. Read and clean data -----
#raw reads from Morphometrix
morpho.output <-read.csv("Data/morpho.output.batch2.csv", header = T)
# get .mp4 file name
morpho.output<-morpho.output%>% mutate(
video.file = substr(imageName, 1, 32)
)
# get within-video whale ID and date
morpho.output <- morpho.output %>% mutate(
video.whale.ID =paste(video.file, ind, sep = "_"),
date = substr(video.whale.ID, 18,25)
)
# get correct altitude data from drone srt files
morpho.output <- getSrtAltitude(morpho.output)
# get correct altitude data from drone srt files
morpho.output <- getSrtAltitude(morpho.output)
# get and ration length estimates
morpho.output<- morpho.output %>% mutate(
altitude.c = altitudeASL(altitude.raw = droneAltitude), #add launch height to barometer altitude:
TL.m = measureWhales(image.width = image_width, altitude = altitudeASL(altitude.raw = droneAltitude),length.pixels = TL.px), #estimate length in meters
HD.m = measureWhales(image.width = image_width, altitude = altitudeASL(altitude.raw = droneAltitude),length.pixels = HD.px), #estimate length in meters
HF.m = measureWhales(image.width = image_width, altitude = altitudeASL(altitude.raw = droneAltitude),length.pixels = HF.px),
ratio.HD = HD.px/TL.px, # ratio using nose-dorsal fin measure
ratio.HF = HF.px/TL.px, # ratio using nose- flipper measure
ratio.DF = HF.px/HD.px # ratio nose-flipper to nose DF
)
# add quality ratings:
# get q. ratings
q.ratings <- read.csv("Data/Processed_Data/morpho.output.QRating.csv", header = T)
q.ratings <- q.ratings %>% mutate(imageName = file_name)
morpho.output <- morpho.output %>%
mutate(ind = as.character(ind)) %>%
left_join(q.ratings %>% mutate(ind = as.character(ind)) %>%
select(imageName, ind, Q.focus, Q.straightness, Q.roll, Q.arch, Q.pitch, Q.meas, Q.dorsal, Q.flippers ),
by = c("imageName", "ind") )
morpho.output<- morpho.output[-which(is.na(morpho.output$Q.focus & morpho.output$notes == "balaena")),]
morpho.output <- morpho.output %>% filter(notes != "balaena")
photo.id <- read.csv("Data/Photo_ID_all.csv", header = T)
View(photo.id)
knitr::opts_chunk$set(echo = TRUE)
setwd("C:/Users/balae/Documents/SpermWhale_SexAge_Drone_VSC")
source("Scripts/00_DJI_Mini_Callibration_Data_Prep.R")
library(ggplot2)
library("wacolors")
px.length <- function(l.m, p.d, f.l = 4.25531, a.m){
(l.m/p.d)*(f.l/a.m)
}
#calculate pixel length:
dat$pixel.length <- px.length(l.m=dat$length,
p.d = dat$pixelDimension.old,
a.m = dat$altitude)
dat<- dat %>% select(Date, FlightNo, imageName, timeStamp, altitudeRaw = altitude, imageWidth = ImageWidth, pixel.length, position = pos, nadir = nadir)
dat<- dat[-which(dat$nadir==F),]
#recalculate Balaena's length in m, with new altitude
boat.height = 1.03- 0.24# balaena's altitude over the water - toe rail
launch.chest = 1.4 # Mateo's chest height
camera.height = 0.045 # cameras distance above the base of the drone's legsfrom legs
dat$altitude.fix <- dat$altitude + launch.chest + camera.height
head(dat)
morpho.length.alpha <- function(image.width, altitude, length.pixels){
alpha = ifelse(image.width == 3840, yes = 0.000328, no =
ifelse(image.width == 1920, yes = 0.000656, no = NA))
length = alpha * altitude * length.pixels
return(length)
}
dat$bal.length<- morpho.length.alpha(altitude = dat$altitude.fix,
image.width = dat$imageWidth,
length.pixels = dat$pixel.length)
summary(dat$bal.length)
hist(dat$bal.length, breaks = 20, xlab = "estimated length of Balaena (m)", main = "")
abline(v = 12.03, col = 2, lwd = 2)
dat$error <- dat$bal.length-12.03
mean(dat$error)
sd(dat$error)
ggplot(dat, aes(x = factor(position), y = error))+
geom_boxplot()
true.altitude <- function(true.length, pixel.length, image.width){
alpha = ifelse(image.width == 3840, yes = 0.000328, no =
ifelse(image.width == 1920, yes = 0.000656, no = NA))
t.a = (true.length/(pixel.length* alpha))
return(t.a)
}
dat$true.altitude <- true.altitude(true.length = 12.03,
pixel.length = dat$pixel.length,
image.width = dat$imageWidth)
dat$altitude.err <- dat$true.altitude - dat$altitude.fix
dat$altitude.err.p <- (dat$altitude.err/dat$true.altitude)
ggplot(dat, aes(x = altitude.fix, y = true.altitude))+
geom_point(alpha = 0.5)+
theme(legend.position = "none")+
geom_smooth(method = "lm")
#
library(nlme)
# non-hierarchical
m.nh <- gls(true.altitude ~ altitude.fix,, data = dat, method = "ML")
summary(m.nh) #AIC = 1405.26/ BIC = 1416.77
# model random intercept :
m.rand.int <- lme(true.altitude ~ altitude.fix, data = dat, method = "ML",
random = ~1|Date)#
summary(m.rand.int) # AIC = 1389.933 BIC = 1405.284	- probably yes?
intervals(m.rand.int, level = 0.95)
#model random intercept and slope:
m.rand <- lme(true.altitude ~ altitude.fix, data = dat, method = "ML",
random = ~altitude.fix|Date)#
summary(m.rand) # AIC = 1389.933 BIC = 1405.284	- probably yes?
dat$fit.nh <- fitted(m.nh) #non-hierarchical
dat$fit.rand.int <- fitted(m.rand.int) #random intercepts
dat$fit.rand <- fitted(m.rand) # random slopes
#compare errors from three models
dat$length.corrected.nh<- morpho.length.alpha(altitude =dat$fit.nh,
image.width = dat$imageWidth,
length.pixels = dat$pixel.length)
dat$length.corrected.rand.int<- morpho.length.alpha(altitude =dat$fit.rand.int,
image.width = dat$imageWidth,
length.pixels = dat$pixel.length)
dat$length.corrected.rand<- morpho.length.alpha(altitude =dat$fit.rand,
image.width = dat$imageWidth,
length.pixels = dat$pixel.length)
dat$length.corrected.0 <- dat$bal.length
dat_long <- dat %>%
pivot_longer(
cols = starts_with("length.corrected"),
names_to = "correction_type",
values_to = "corrected_altitude"
)%>%
mutate(error = corrected_altitude - 12.03,
error_p = 100*(error/12.03))
ggplot(dat_long, aes(x = error_p, fill = correction_type)) +
stat_halfeye(alpha = 0.5, adjust = 1) +
theme_classic() +
labs(
title = "Density plots of corrected altitudes",
x = "Error %",
y = "Density",
fill = "Correction Type"
)+
facet_wrap(~correction_type, ncol = 1)+
theme(legend.position = "None")+scale_fill_wa_d("rainier")
dat_long %>%
group_by(correction_type)%>%
summarise(mean_err = mean(error),
mean_err_p = mean(error_p),
quant_5 = quantile(error_p, probs = 0.025),
quant_95 = quantile(error_p, probs = 0.975),
ic_range = quant_95-quant_5)
dat_long %>%
group_by(correction_type)%>%
summarise(mean_err = mean(error),
mean_err_p = mean(error_p),
quant_5 = quantile(error_p, probs = 0.025),
quant_95 = quantile(error_p, probs = 0.975),
ic_range = quant_95-quant_5,
sd = sd(error_p))
sample(x = 1:10, size = 10)
sample(x = 1:10, size = 10, replace = T)
#bootstraping:
data(iris)
library(boot)
foo <- function(data, indices){
dt <- data[indices,]#subset data
c(
cor(dt[,1], dt[,2], method = "s"),
median(dt[,1]),
median(dt[,2])
)
}
foo <- function(data, indices, cor.type){
dt <- data[indices,]#subset data
c(
cor(dt[,1], dt[,2], method = cor.type),
median(dt[,1]),
median(dt[,2])
)
}
set.seed(1991)
?boot
myBoot <-boot(iris, foo, R = 1000, cor.type = 's')
myBoot
head(myBoot$t)
myBoot$t0
head(myBoot$t) #values obtained in each bootstrap
myBoot$t0 # observed values for full dataset
myBoot
colMeans(myBootstrap$t)-myBootstrap$t0
colMeans(myBoot$t)-myBootstrap$t0
colMeans(myBoot$t)-myBoot$t0
myBoot$t0 # observed values for full dataset
colMeans(myBoot$t)
plot(myBoot)
plot(myBoot, index = 2)
plot(myBoot, index = 3)
boot.ci(myBoot)
boot.ci(myBoot, index = 3)
dat$altitude.err
gls(true.altitude ~ altitude.fix,, data = dat, method = "ML")
gls(true.altitude ~ altitude.fix,, data = dat, method = "ML", quiet = T)
gls(true.altitude ~ altitude.fix,, data = dat, method = "ML", silent = T)
gls(true.altitude ~ altitude.fix,, data = dat, method = "ML", verbose = F)
m<-gls(true.altitude ~ altitude.fix,, data = dat, method = "ML", verbose = F)
coef(m)
coef(m)[1]
coef(m)[2]
unname(coef(m)[1])
foo <- function(data, indices){
dt <- data[indices,]#subset data
m<-gls(true.altitude ~ altitude.fix,, data = dat, method = "ML", verbose = F)
c(
unname(coef(m)[1]),
unname(coef(m)[2])
)
}
foo <- function(data, indices){
dt <- data[indices,]#subset data
m<-gls(true.altitude ~ altitude.fix,, data = dt, method = "ML", verbose = F)
c(
unname(coef(m)[1]),
unname(coef(m)[2])
)
}
myBoot <-boot(dat, foo, R = 1000)
myBoot$t0
colMeans(myBoot$t)
head(myBoot$t)
plot(myBoot, index = 1)
plot(myBoot, index = 2)
boot.ci(myBoot, index = 1)#basic ci.
boot.ci(myBoot, index = 2)#basic ci.
foo <- function(data, indices){
dt <- data[indices,]#subset data
m<-gls(true.altitude ~ altitude.fix,, data = dt, method = "ML", verbose = F)
c(
unname(coef(m)[1]),#intercept
unname(coef(m)[2])# slope
dt$true.altitude - dt$altitude.fix #error
c(
unname(coef(m)[1]),#intercept
unname(coef(m)[2]),# slope
dt$true.altitude - dt$altitude.fix #error
)
foo <- function(data, indices){
dt <- data[indices,]#subset data
m<-gls(true.altitude ~ altitude.fix,, data = dt, method = "ML", verbose = F)
c(
unname(coef(m)[1]),#intercept
unname(coef(m)[2]),# slope
dt$true.altitude - dt$altitude.fix #error
)
}
myBoot <-boot(dat, foo, R = 1000)
myBoot$t0
colMeans(myBoot$t)
c(
unname(coef(m)[1]),#intercept
unname(coef(m)[2]),# slope
range(dt$true.altitude - dt$altitude.fix) #error
)
foo <- function(data, indices){
dt <- data[indices,]#subset data
m<-gls(true.altitude ~ altitude.fix,, data = dt, method = "ML", verbose = F)
c(
unname(coef(m)[1]),#intercept
unname(coef(m)[2]),# slope
range(dt$true.altitude - dt$altitude.fix) #error
)
}
myBoot <-boot(dat, foo, R = 1000)
myBoot$t0
foo <- function(data, indices){
dt <- data[indices,]#subset data
m<-gls(true.altitude ~ altitude.fix,, data = dt, method = "ML", verbose = F)
c(
unname(coef(m)[1]),#intercept
unname(coef(m)[2]),# slope
sd(dt$true.altitude - dt$altitude.fix) #error
)
}
myBoot <-boot(dat, foo, R = 1000)
myBoot$t0
colMeans(myBoot$t)
id.mean <- id.morph %>%
group_by(ID) %>%
summarize(mean_TL = mean(TL.m, na.rm = T), cv_TL = (sd(TL.m, na.rm = T)/mean_TL)*100, sd_TL = sd(TL.m, na.rm = T),
mean_HD = mean(HD.m, na.rm = T), cv_HD = (sd(HD.m, na.rm = T)/mean_HD)*100, sd_HD = sd(HD.m, na.rm = T),
mean_HF = mean(HF.m, na.rm = T), cv_HF = (sd(HF.m, na.rm = T)/mean_HF)*100, sd_HF = sd(HD.m, na.rm = T),
mean_ratio.HD = mean(ratio.HD, na.rm = T), cv_ratio.HD = (sd(ratio.HD, na.rm = T)/mean_ratio.HD), sd_ratio.HD = sd(ratio.HD, na.rm = T),
mean_ratio.HF = mean(ratio.HF, na.rm = T), cv_ratio.HF = (sd(ratio.HF, na.rm = T)/mean_ratio.HF), sd_ratio.HF = sd(ratio.HF, na.rm = T),
n_photos = n(),
date = first(date),
mean_altitude= mean(altitude.c))
id.morph <- morpho.output%>%
filter(!is.na(ID))
# Load required packages
source("Scripts/functions.R")
library(tidyverse)
# 1. Read and clean data -----
#raw reads from Morphometrix
morpho.output <-read.csv("Data/morpho.output.batch2.csv", header = T)
# get .mp4 file name
morpho.output<-morpho.output%>% mutate(
video.file = substr(imageName, 1, 32)
)
# get within-video whale ID and date
morpho.output <- morpho.output %>% mutate(
video.whale.ID =paste(video.file, ind, sep = "_"),
date = substr(video.whale.ID, 18,25)
)
# get correct altitude data from drone srt files
morpho.output <- getSrtAltitude(morpho.output)
# get and ration length estimates
morpho.output<- morpho.output %>% mutate(
altitude.c = altitudeASL(altitude.raw = droneAltitude), #add launch height to barometer altitude:
TL.m = measureWhales(image.width = image_width, altitude = altitudeASL(altitude.raw = droneAltitude),length.pixels = TL.px), #estimate length in meters
HD.m = measureWhales(image.width = image_width, altitude = altitudeASL(altitude.raw = droneAltitude),length.pixels = HD.px), #estimate length in meters
HF.m = measureWhales(image.width = image_width, altitude = altitudeASL(altitude.raw = droneAltitude),length.pixels = HF.px),
ratio.HD = HD.px/TL.px, # ratio using nose-dorsal fin measure
ratio.HF = HF.px/TL.px, # ratio using nose- flipper measure
ratio.DF = HF.px/HD.px # ratio nose-flipper to nose DF
)
# add quality ratings:
# get q. ratings
q.ratings <- read.csv("Data/Processed_Data/morpho.output.QRating.csv", header = T)
q.ratings <- q.ratings %>% mutate(imageName = file_name)
morpho.output <- morpho.output %>%
mutate(ind = as.character(ind)) %>%
left_join(q.ratings %>% mutate(ind = as.character(ind)) %>%
select(imageName, ind, Q.focus, Q.straightness, Q.roll, Q.arch, Q.pitch, Q.meas, Q.dorsal, Q.flippers ),
by = c("imageName", "ind") )
morpho.output<- morpho.output[-which(is.na(morpho.output$Q.focus & morpho.output$notes == "balaena")),]
morpho.output <- morpho.output %>% filter(notes != "balaena")
photo.id <- read.csv("Data/Photo_ID_all.csv", header = T)
# Load required packages
source("Scripts/functions.R")
library(tidyverse)
# 1. Read and clean data -----
#raw reads from Morphometrix
morpho.output <-read.csv("Data/morpho.output.batch2.csv", header = T)
# get .mp4 file name
morpho.output<-morpho.output%>% mutate(
video.file = substr(imageName, 1, 32)
)
# get within-video whale ID and date
morpho.output <- morpho.output %>% mutate(
video.whale.ID =paste(video.file, ind, sep = "_"),
date = substr(video.whale.ID, 18,25)
)
# get correct altitude data from drone srt files
morpho.output <- getSrtAltitude(morpho.output)
# get and ration length estimates
morpho.output<- morpho.output %>% mutate(
altitude.c = altitudeASL(altitude.raw = droneAltitude), #add launch height to barometer altitude:
TL.m = measureWhales(image.width = image_width, altitude = altitudeASL(altitude.raw = droneAltitude),length.pixels = TL.px), #estimate length in meters
HD.m = measureWhales(image.width = image_width, altitude = altitudeASL(altitude.raw = droneAltitude),length.pixels = HD.px), #estimate length in meters
HF.m = measureWhales(image.width = image_width, altitude = altitudeASL(altitude.raw = droneAltitude),length.pixels = HF.px),
ratio.HD = HD.px/TL.px, # ratio using nose-dorsal fin measure
ratio.HF = HF.px/TL.px, # ratio using nose- flipper measure
ratio.DF = HF.px/HD.px # ratio nose-flipper to nose DF
)
# add quality ratings:
# get q. ratings
q.ratings <- read.csv("Data/Processed_Data/morpho.output.QRating.csv", header = T)
q.ratings <- q.ratings %>% mutate(imageName = file_name)
morpho.output <- morpho.output %>%
mutate(ind = as.character(ind)) %>%
left_join(q.ratings %>% mutate(ind = as.character(ind)) %>%
select(imageName, ind, Q.focus, Q.straightness, Q.roll, Q.arch, Q.pitch, Q.meas, Q.dorsal, Q.flippers ),
by = c("imageName", "ind") )
morpho.output<- morpho.output[-which(is.na(morpho.output$Q.focus & morpho.output$notes == "balaena")),]
morpho.output <- morpho.output %>% filter(notes != "balaena")
photo.id <- read.csv("Data/Photo_ID_all.csv", header = T)
photo.id <- photo.id %>%
mutate(ind = str_extract(Keywords, "ind\\d+") %>% str_remove("ind"),
video.file = substr(RawFileName, 1, 32),
video.whale.ID = paste(video.file, ind, sep = "_"),
snapshot.ID= paste(RawFileName, ind, sep = "_"))
photo.id <-photo.id %>%
mutate(class = case_when(
str_detect(Keywords, "male") ~ "male",
str_detect(Keywords, "juanito") ~ "juanito",
TRUE ~ NA
))
# error check:
photo.id %>%
group_by(ID) %>%
summarize(unique_inds = n_distinct(Caption), .groups = "drop") %>%
filter(unique_inds > 1)  # nice!
morpho.output <-morpho.output %>%
mutate(snapshot.ID = paste(imageName, ind, sep = "_"))
morpho.output<- left_join(morpho.output, photo.id, by  ="snapshot.ID")
# remove rogue duplicate
morpho.output <- morpho.output %>%
distinct(snapshot.ID, .keep_all = TRUE)
#remove image with no quality rating
morpho.output <-morpho.output %>%
filter(!is.na(Q))
id.morph <- morpho.output%>%
filter(!is.na(ID))
id.mean <- id.morph %>%
group_by(ID) %>%
summarize(mean_TL = mean(TL.m, na.rm = T), cv_TL = (sd(TL.m, na.rm = T)/mean_TL)*100, sd_TL = sd(TL.m, na.rm = T),
mean_HD = mean(HD.m, na.rm = T), cv_HD = (sd(HD.m, na.rm = T)/mean_HD)*100, sd_HD = sd(HD.m, na.rm = T),
mean_HF = mean(HF.m, na.rm = T), cv_HF = (sd(HF.m, na.rm = T)/mean_HF)*100, sd_HF = sd(HD.m, na.rm = T),
mean_ratio.HD = mean(ratio.HD, na.rm = T), cv_ratio.HD = (sd(ratio.HD, na.rm = T)/mean_ratio.HD), sd_ratio.HD = sd(ratio.HD, na.rm = T),
mean_ratio.HF = mean(ratio.HF, na.rm = T), cv_ratio.HF = (sd(ratio.HF, na.rm = T)/mean_ratio.HF), sd_ratio.HF = sd(ratio.HF, na.rm = T),
n_photos = n(),
date = first(date),
mean_altitude= mean(altitude.c))
hd<-id.mean%>%
filter(n_photos>1 & !is.na(mean_HD))
hf<-id.mean%>%
filter(n_photos>1 & !is.na(mean_HF))
# 2. Explore Quality and identifyiablity-----
# Load required libraries
library(ggplot2)
library(ggpubr)
library(dplyr)
p1<- ggplot(morpho.output, aes(x = as.factor(Q), y = altitude.c, fill = as.factor(Q))) +
geom_boxplot() +
geom_jitter(width = 0.12, alpha = 0.6) +
scale_fill_brewer(palette = "Greens") +
theme_classic()+
theme(legend.position = "none") +
geom_hline(yintercept = 70, lty = "dashed")+
labs(x = "Q rating", y = "Altitude (m)")
p1
View(id.mean)
#save
write.csv(id.mean, "Data/Processed_Data/id_morpho_output_clean_processed.csv")
#save
write.csv(id.mean, "Data/Processed_Data/id_morpho_output_clean_processed.csv")
