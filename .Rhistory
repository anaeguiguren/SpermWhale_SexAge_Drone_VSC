rm(data)
#group by ID:
data.ID<- data %>%
group_by(ID) %>%
summarise(Length = first(Length), True_ratio = first(true_ratio),
Ratio = mean(Ratio), Sex = first(Sex), SD_Ratio = first(sd_R))%>%
mutate(upper = Ratio + SD_Ratio, lower = Ratio - SD_Ratio)
# Use optim_sex to fit parameters with weighted regression
fit <- try({
optim_sex(data.ID, chm = chm, pard0 = pard0, weighted = FALSE)
}, silent = TRUE)
if(!inherits(fit, "try-error")) {
# Calculate posterior probabilities of being female
data.ID$fem_probs <- f_probs(fit$params, data.ID, chm = chm)
# Find optimal threshold and get classification performance
perf <- model_perf(bin_sex = (data.ID$Sex == "F"), fem_probs = data.ID$fem_probs)
# Calculate accuracy using optimal threshold
data.ID$predicted_sex <- ifelse(data.ID$fem_probs >= perf$threshold, "F", "M")
accuracy <- mean(predicted_sex == data.ID$Sex)
# Store results
sim_results[[sim]] <- data.frame(
uncertainty = uncertainty_sd,
simulation = sim,
accuracy = accuracy,
threshold = perf$threshold,
true_pos = perf$true.pos,
true_neg = perf$true.neg,
fr = fit$params[1],
fmax = fit$params[2],
mr = fit$params[3],
mmax = fit$params[4]
)
}
}
# Combine results for this uncertainty level
results[[i]] <- do.call(rbind, sim_results)
# Print progress
cat(sprintf("Completed uncertainty level %d of %d\n", i, length(uncertainty_levels)))
}
# Initial parameter guesses (same as in functions.R)
pard0 <- c(0.2, 0.2, 0.02, 0.2)  # fr, fmax, mr, mmax
for(i in seq_along(uncertainty_levels)) {
uncertainty_sd <- uncertainty_levels[i]
sim_results <- list()
for(sim in 1:n_sims) {
# Generate dataset with current uncertainty level
data <- generate_dataset(uncertainty_sd, params.true)
# Weight by inverse variance of measurements
data$SD_Ratio <- data$sd_R  # Match name expected by optim_sex
#group by ID:
data.ID<- data %>%
group_by(ID) %>%
summarise(Length = first(Length), True_ratio = first(true_ratio),
Ratio = mean(Ratio), Sex = first(Sex), SD_Ratio = first(sd_R))%>%
mutate(upper = Ratio + SD_Ratio, lower = Ratio - SD_Ratio)
#remove to mak sure I'm using the right data frame
rm(data)
# Use optim_sex to fit parameters with weighted regression
fit <- try({
optim_sex(data.ID, chm = chm, pard0 = pard0, weighted = FALSE)
}, silent = TRUE)
if(!inherits(fit, "try-error")) {
# Calculate posterior probabilities of being female
data.ID$fem_probs <- f_probs(fit$params, data.ID, chm = chm)
# Find optimal threshold and get classification performance
perf <- model_perf(bin_sex = (data.ID$Sex == "F"), fem_probs = data.ID$fem_probs)
# Calculate accuracy using optimal threshold
data.ID$predicted_sex <- ifelse(data.ID$fem_probs >= perf$threshold, "F", "M")
accuracy <- mean(predicted_sex == data.ID$Sex)
# Store results
sim_results[[sim]] <- data.frame(
uncertainty = uncertainty_sd,
simulation = sim,
accuracy = accuracy,
threshold = perf$threshold,
true_pos = perf$true.pos,
true_neg = perf$true.neg,
fr = fit$params[1],
fmax = fit$params[2],
mr = fit$params[3],
mmax = fit$params[4]
)
}
}
# Combine results for this uncertainty level
results[[i]] <- do.call(rbind, sim_results)
# Print progress
cat(sprintf("Completed uncertainty level %d of %d\n", i, length(uncertainty_levels)))
}
for(i in seq_along(uncertainty_levels)) {
uncertainty_sd <- uncertainty_levels[i]
sim_results <- list()
for(sim in 1:n_sims) {
# Generate dataset with current uncertainty level
data <- generate_dataset(uncertainty_sd, params.true)
# Weight by inverse variance of measurements
data$SD_Ratio <- data$sd_R  # Match name expected by optim_sex
#group by ID:
data.ID<- data %>%
group_by(ID) %>%
summarise(Length = first(Length), True_ratio = first(true_ratio),
Ratio = mean(Ratio), Sex = first(Sex), SD_Ratio = first(sd_R))%>%
mutate(upper = Ratio + SD_Ratio, lower = Ratio - SD_Ratio)
#remove to mak sure I'm using the right data frame
rm(data)
# Use optim_sex to fit parameters with weighted regression
fit <- try({
optim_sex(data.ID, chm = chm, pard0 = pard0, weighted = FALSE)
}, silent = TRUE)
if(!inherits(fit, "try-error")) {
# Calculate posterior probabilities of being female
data.ID$fem_probs <- f_probs(fit$params, data.ID, chm = chm)
# Find optimal threshold and get classification performance
perf <- model_perf(bin_sex = (data.ID$Sex == "F"), fem_probs = data.ID$fem_probs)
# Calculate accuracy using optimal threshold
data.ID$predicted_sex <- ifelse(data.ID$fem_probs >= perf$threshold, "F", "M")
accuracy <- mean(data.ID$predicted_sex == data.ID$Sex)
# Store results
sim_results[[sim]] <- data.frame(
uncertainty = uncertainty_sd,
simulation = sim,
accuracy = accuracy,
threshold = perf$threshold,
true_pos = perf$true.pos,
true_neg = perf$true.neg,
fr = fit$params[1],
fmax = fit$params[2],
mr = fit$params[3],
mmax = fit$params[4]
)
}
}
# Combine results for this uncertainty level
results[[i]] <- do.call(rbind, sim_results)
# Print progress
cat(sprintf("Completed uncertainty level %d of %d\n", i, length(uncertainty_levels)))
}
# Combine results for this uncertainty level
results[[i]] <- do.call(rbind, sim_results)
# Combine all results
final_results <- do.call(rbind, results)
View(final_results)
# Save results
write.csv(final_results, "uncertainty_analysis_results.csv", row.names = FALSE)
# Enhanced visualization with uncertainty bands
ggplot(final_results, aes(x = uncertainty)) +
geom_point(aes(y = accuracy), alpha = 0.1) +
geom_smooth(aes(y = accuracy), method = "loess", se = TRUE) +
geom_smooth(aes(y = true_pos), method = "loess", se = TRUE, color = "red") +
geom_smooth(aes(y = true_neg), method = "loess", se = TRUE, color = "blue") +
labs(x = "Measurement Uncertainty (SD)",
y = "Performance Metrics",
title = "Impact of Measurement Uncertainty on Classification Performance",
subtitle = "Black: Overall Accuracy, Red: True Positive Rate, Blue: True Negative Rate") +
theme_minimal()
View(final_results)
ggplot(final_results, aes(x = uncertainty, y = accuracy)) +
geom_boxplot()
ggplot(final_results, aes(x = factor(uncertainty), y = accuracy)) +
geom_boxplot()
ggplot(final_results, aes(x = factor(uncertainty), y = true_pos)) +
geom_boxplot()
data <- generate_dataset(uncertainty_sd = 0.02, params.true)
data.ID<- data %>%
group_by(ID) %>%
summarise(Length = first(Length), True_ratio = first(true_ratio),
Ratio = mean(Ratio), Sex = first(Sex), SD_Ratio = first(sd_R))%>%
mutate(upper = Ratio + SD_Ratio, lower = Ratio - SD_Ratio)
head(data.ID)
ggplot(data.ID, aes(x = Length, y = Ratio, colour = Sex))+
geom_point()+
geom_errorbar(aes(ymin = lower, ymax = upper))+
geom_point(aes(x = Length, y = True_ratio), colour = "black", alpha = 0.5)
ggplot(data.ID, aes(x = Length, y = Ratio, colour = fem_probs))+
geom_point()+
geom_errorbar(aes(ymin = lower, ymax = upper))
# Use optim_sex to fit parameters with weighted regression
fit <- try({
optim_sex(data.ID, chm = chm, pard0 = pard0, weighted = FALSE)
}, silent = TRUE)
true.params
params.true
ggplot(data.ID, aes(x = Length, y = Ratio, colour = fem_probs))+
geom_point()+
geom_errorbar(aes(ymin = lower, ymax = upper))
data.ID$fem_probs <- f_probs(fit$params, data.ID, chm = chm)
ggplot(data.ID, aes(x = Length, y = Ratio, colour = Sex))+
geom_point()+
geom_errorbar(aes(ymin = lower, ymax = upper))+
geom_point(aes(x = Length, y = True_ratio), colour = "black", alpha = 0.5)
ggplot(data.ID, aes(x = Length, y = Ratio, colour = fem_probs))+
geom_point()+
geom_errorbar(aes(ymin = lower, ymax = upper))
geom_point(aes(x = Length, y = True_ratio), colour = "black", alpha = 0.5)
ggplot(data.ID, aes(x = Length, y = Ratio, colour = fem_probs))+
geom_point()+
geom_errorbar(aes(ymin = lower, ymax = upper))+
geom_point(aes(x = Length, y = True_ratio), colour = "black", alpha = 0.5)
# Load required libraries
library(tidyverse)  # for data manipulation and plotting
library(purrr)      # for mapping functions
library(dplyr)      # for data manipulation
library(ggplot2)
library(wacolors)
source("Scripts/functions.R")
# Parameters from Nishiwaki
params.true <- read.csv("Data/nishiwaki_parameters.csv")
# Simulation parameters
n_sims <- 100            # simulations per uncertainty level
n_whales <- 30           # whales per sex
n_measurements <- 3      # repeated measurements per whale
min.L <- 4              # minimum length
max.L.F <- 11          # max female length
max.L.M <- 17          # max male length
mean.L.F <- 8          # mean female length
mean.L.M <- 12         # mean male length
chm <- 6               # change point for male growth
biological_sd <- 0.005  # biological variation in length-ratio relationship
# True parameters from Nishiwaki
fmax <- params.true$Value[1]
fr <- params.true$Value[3]
mmax <- params.true$Value[2]
mr <- params.true$Value[4]
# Define uncertainty levels to test (SD of measurements)
uncertainty_levels <- seq(0.001, 0.02, length.out = 20)
results <- list()
# Initial parameter guesses (same as in functions.R)
pard0 <- c(0.2, 0.2, 0.02, 0.2)  # fr, fmax, mr, mmax
for(i in seq_along(uncertainty_levels)) {
uncertainty_sd <- uncertainty_levels[i]
sim_results <- list()
for(sim in 1:n_sims) {
# Generate dataset with current uncertainty level
data <- generate_dataset(uncertainty_sd, params.true)
# Weight by inverse variance of measurements
data$SD_Ratio <- data$sd_R  # Match name expected by optim_sex
#group by ID:
data.ID<- data %>%
group_by(ID) %>%
summarise(Length = first(Length), True_ratio = first(true_ratio),
Ratio = mean(Ratio), Sex = first(Sex), SD_Ratio = first(sd_R))%>%
mutate(upper = Ratio + SD_Ratio, lower = Ratio - SD_Ratio)
#remove to mak sure I'm using the right data frame
rm(data)
# Use optim_sex to fit parameters with weighted regression
fit <- try({
optim_sex(data.ID, chm = chm, pard0 = pard0, weighted = FALSE)
}, silent = TRUE)
if(!inherits(fit, "try-error")) {
# Calculate posterior probabilities of being female
data.ID$fem_probs <- f_probs(fit$params, data.ID, chm = chm)
# Find optimal threshold and get classification performance
perf <- model_perf(bin_sex = (data.ID$Sex == "F"), fem_probs = data.ID$fem_probs)
# Calculate accuracy using optimal threshold
data.ID$predicted_sex <- ifelse(data.ID$fem_probs >= perf$threshold, "F", "M")
accuracy <- mean(data.ID$predicted_sex == data.ID$Sex)
# Store results
sim_results[[sim]] <- data.frame(
uncertainty = uncertainty_sd,
simulation = sim,
accuracy = accuracy,
threshold = perf$threshold,
true_pos = perf$true.pos,
true_neg = perf$true.neg,
fr = fit$params[1],
fmax = fit$params[2],
mr = fit$params[3],
mmax = fit$params[4]
)
}
}
# Combine results for this uncertainty level
results[[i]] <- do.call(rbind, sim_results)
# Print progress
cat(sprintf("Completed uncertainty level %d of %d\n", i, length(uncertainty_levels)))
}
# Combine all results
final_results <- do.call(rbind, results)
# Save results
write.csv(final_results, "uncertainty_analysis_results.csv", row.names = FALSE)
# Enhanced visualization with uncertainty bands
ggplot(final_results, aes(x = uncertainty)) +
geom_point(aes(y = accuracy), alpha = 0.1) +
geom_smooth(aes(y = accuracy), method = "loess", se = TRUE) +
geom_smooth(aes(y = true_pos), method = "loess", se = TRUE, color = "red") +
geom_smooth(aes(y = true_neg), method = "loess", se = TRUE, color = "blue") +
labs(x = "Measurement Uncertainty (SD)",
y = "Performance Metrics",
title = "Impact of Measurement Uncertainty on Classification Performance",
subtitle = "Black: Overall Accuracy, Red: True Positive Rate, Blue: True Negative Rate") +
theme_minimal()
ggplot(final_results, aes(x = factor(uncertainty), y = accuracy)) +
geom_boxplot()
ggplot(final_results, aes(x = factor(uncertainty), y = true_pos)) +
geom_boxplot()
ggplot(final_results, aes(x = factor(uncertainty), y = accuracy)) +
geom_boxplot()+
scale_y_continuous(limits = c(0,1))
ggplot(final_results, aes(x = factor(uncertainty), y = accuracy)) +
geom_boxplot()+
geom_hline(yintercept = 0.96, linetype = "dashed", color = "red")
ggplot(final_results, aes(x = factor(uncertainty), y = accuracy)) +
geom_boxplot()+
geom_hline(yintercept = 0.96, linetype = "dashed", color = "red")+
scale_y_continuous(limits = c(0,1))
ggplot(final_results, aes(x = factor(uncertainty), y = accuracy)) +
geom_boxplot()+
geom_hline(yintercept = 0.80, linetype = "dashed", color = "red")+
scale_y_continuous(limits = c(0,1))
ggplot(final_results, aes(x = factor(uncertainty), y = true_pos)) +
geom_hline(yintercept = 0.80, linetype = "dashed", color = "red")+
geom_boxplot()
ggplot(final_results, aes(x = factor(uncertainty), y = true_pos)) +
geom_hline(yintercept = 0.80, linetype = "dashed", color = "red")+
geom_boxplot()+
scale_y_continuous(limits = c(0,1))
ggplot(final_results, aes(x = factor(uncertainty), y = true_pos)) +
geom_boxplot()+
geom_hline(yintercept = 0.80, linetype = "dashed", color = "red")+
scale_y_continuous(limits = c(0,1))
ggplot(final_results, aes(x = factor(uncertainty), y = true_pos)) +
geom_boxplot()+
geom_hline(yintercept = 0.90, linetype = "dashed", color = "red")+
scale_y_continuous(limits = c(0,1))
?optim
#~~~a. Define female and male curve shapes ----
fem_curve <- function(length, fr, fmax) {
fmax * exp(fr * length) / (1 + exp(fr * length))
}
mal_curve <- function(length, fr, fmax, mr, mmax, chm){
base <- fmax * exp(fr  * length) / (1 + exp(fr * length))
offset <- (length > chm) * mmax *
(exp(mr * length) / (1 + exp(mr * length)) -
exp(mr * chm) / (1 + exp(mr * chm)))
Ratio <- base + offset
return(Ratio)
}
sumsq <- function(params, data, chm, weighted = FALSE){
fr <- params[1]
fmax <- params[2]
mr <- params[3]
mmax <- params[4]
preds_f <- fem_curve(data$Length, fr, fmax)
preds_m <- mal_curve(data$Length, fr, fmax, mr, mmax, chm)
resid_f <- (data$Ratio - preds_f)^2 #female sum of squares
resid_m <- (data$Ratio - preds_m)^2 # male sum of squares
residuals <- pmin(resid_f, resid_m) #returns the minimum of each curve for each data point
#when weighted by SD:
if(weighted){
ss <- sum(residuals/data$SD_Ratio) #sum of squares divided by sd
return(ss)
}else{
likes <- cbind(resid_f, resid_m)
ss <- sum(residuals)
return(list(ss = ss, likes = likes))
}
}
#~~~c. Fit parameters using optim ----
optim_sex <- function(data, chm, pard0, weighted = FALSE){
objfun <- function(p){ #this is the thing we want to minimize (optimize)
if(weighted) {
sumsq(p, data, chm, TRUE)
}else{
sumsq(p, data, chm, FALSE)$ss
}
}
fit <- optim(pard0, objfun, method = "Nelder-Mead" )
params <- fit$par
ss <- fit$value
cat(ifelse(weighted, "Weighted SS", "Unweighted SS"), "\n")
cat(sprintf("Sum of squares: %6.4f\n", ss)) #what are these percentages about?
cat(sprintf("Fitted parameters: fr = %5.2f, fmax = %5.2f, mr = %5.2f, mmax = %5.2f\n",
params[1], params[2], params[3], params[4]))
list(params = params, ss = ss, fit = fit)
}
f_probs <- function(params, data, chm = 6, weighted = FALSE) {
res <- sumsq(params, data, chm)
likes <- exp(-res$likes / (2 * res$ss / (nrow(res$likes) - 1)))
post_probs <- likes[, 1] / rowSums(likes)
return(post_probs)
}
source("Scripts/functions.R")
set.seed(1991)
# 1. generate ratios (R) for male and females to match Nishiwaki-----
params.true <- read.csv("Data/nishiwaki_parameters.csv")
n <- 30 # number of whales of each sex
min.L <- 4 # length at birth
max.L.F <- 11 # max length females
mean.L.F <- 8 # guestimated mean length of females
# simmulate female lengths - truncated normal distribution
x_F <- rnorm(n, mean = mean.L.F, sd = (max.L.F - mean.L.F) / 3) %>%
# Truncate values to be between min and max length
pmax(min.L) %>%
pmin(max.L.F)
# Verify the distribution
hist(x_F, breaks = 10, main = "Distribution of Female Lengths",
xlab = "Length (m)")
fmax <- params.true$Value[1]
print(fmax) #maximum ntb ratio
fr <- params.true$Value[3]
print(fr) #initial growth rate (same for males and females)
y_F <-  fmax * exp(fr * x_F) / (1 + exp(fr * x_F)) +
rnorm(n, mean = 0, sd = 0.005) #add noise
# simulate male lengths
mean.L.M <- 12
max.L.M <- 17
#uniform distribution of males, young adults should leave
x_M <- runif(n, min = min.L, max = max.L.M)
hist(x_M)
# simulate male ratios in a piecewise manner
mmax <- params.true$Value[2] #maximum ntb ratio
mr <- params.true$Value[4] # male growth rate post 6 m
chm <- 6 # size at which growth rate changes
base <- fmax * exp(fr * x_M) / (1 + exp(fr * x_M))
offset <- (x_M > chm) * mmax * (
exp(mr * x_M) / (1 + exp(mr * x_M)) -
exp(mr * chm) / (1 + exp(mr * chm))
)
noise <- rnorm(n, mean = 0, sd = 0.005)
y_M <- base + offset + noise
# 2. visualize simulated data----
df <- data.frame(Length = c(x_F, x_M),
Ratio = c(y_F, y_M),
Sex = rep(c("F", "M"), each = 30))
# Create a sequence of lengths for the female lines
f_line <- data.frame(
Length = seq(min.L, max.L.F, by = 0.2)
)
f_line <- f_line %>%
mutate(Ratio = fem_curve(Length, fr, fmax))
m_line <- data.frame(
Length = seq(min.L, max.L.M, by = 0.2)
)
m_line <- m_line %>%
mutate(Ratio = mal_curve(Length, fr, fmax, mr, mmax, chm = 6))
# visualize points
fem_col <- "darkcyan"
mal_col <- "darkorange"
ggplot(df, aes(x = Length, y = Ratio, colour = Sex)) +
geom_point(alpha = 0.6) +
geom_line(data = f_line, aes(x = Length, y = Ratio),
inherit.aes = FALSE, colour = fem_col) +
geom_line(data = m_line, aes(x = Length, y = Ratio),
inherit.aes = FALSE, colour = mal_col,) +
scale_color_manual(values = c("F" = fem_col, "M" = mal_col)) +
labs(title = "Simulated Growth Curves with Curves with known
parameters from Nishiwaki 1963",
x = "Total Length (m)",
y = "Nose-to-Body Ratio") +
theme_classic()
data = df
chm = 6
pard0 = c(fr = 0.5, fmax = 0.5, mr = 0.5, mmax = 0.5)
weighted = F
fit_result <- optim_sex(data = df, chm = 6,
pard0 = c(fr = 0.5, fmax = 0.5, mr = 0.5, mmax = 0.5),
weighted = F)
#extract estimated parameters:
params.est <- fit_result$params
fit_result
objfun <- function(p){ #this is the thing we want to minimize (optimize)
if(weighted) {
sumsq(p, data, chm, TRUE)
}else{
sumsq(p, data, chm, FALSE)$ss
}
}
fit <- optim(pard0, objfun, method = "Nelder-Mead" )
fit
?optim
fit <- optim(pard0, objfun, method = "BGFS" )
fit <- optim(pard0, objfun, method = "BFGS" )
fit
fit <- optim(pard0, objfun, method = "CG" , maxit = 2000)
fit <- optim(pard0, objfun, method = "CG" , control= list(maxit = 500))
fit
fit <- optim(pard0, objfun, method = "CG" , control= list(maxit = 20000))
fit
fit <- optim(pard0, objfun, method = "BFGS" , control= list(maxit = 20000))
fit
fit <- optim(pard0, objfun,control= list(maxit = 20000))
fit
params
fit <- optim(pard0, objfun, control= list(maxit = 205000))
params <- fit$par
params
ss <- fit$value
ss
fr <- params[1]
fmax <- params[2]
mr <- params[3]
mmax <- params[4]
preds_f <- fem_curve(data$Length, fr, fmax)
preds_m <- mal_curve(data$Length, fr, fmax, mr, mmax, chm)
resid_f <- (data$Ratio - preds_f)^2 #female sum of squares
resid_m <- (data$Ratio - preds_m)^2 # male sum of squares
residuals <- pmin(resid_f, resid_m) #returns the minimum of each curve for each data point
residuals
likes <- cbind(resid_f, resid_m)
ss <- sum(residuals)
likes
ss <- sum(residuals)
ss
res <- sumsq(params, data, chm)
res
res$likes
likes <- exp(-res$likes / (2 * res$ss / (nrow(res$likes) - 1)))
likes
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE)
unlink("~/trying_cache", recursive = TRUE)
rowSums(likes)
